# OSLab 实验文档

## 简介

本实验为实现基于Risc-V的内核操作系统，完善并新增了一系列系统调用，完善用户体验并提高性能。

本实验在截止日期前达到97/103的分数。

### 环境配置

本实验的环境配置十分繁琐，为方便后人进行该实验的配置，笔者已经将配置的过程方法整理至[知乎](https://zhuanlan.zhihu.com/p/2287226496)。

### 系统调用概述

系统调用方式遵循RISC-V ABI,即调用号存放在a7寄存器中,6个参数分别储存在a0-a5寄存器中,返回值保存在a0中。
主要参考了Linux 5.10 syscalls，详细请[参见](https://man7.org/linux/man-pages/man2/syscalls.2.html)，本实验实现了以下系统调用，其中结尾带_的为调用xv6原有的系统调用。

```
#define SYS_getcwd_     17
#define SYS_dup_        23
#define SYS_dup3        24
#define SYS_mkdirat     34
#define SYS_unlinkat    35
#define SYS_umount2     39
#define SYS_mount       40
#define SYS_chdir_      49
#define SYS_openat      56
#define SYS_close_      57
#define SYS_pipe2       59
#define SYS_getdents64  61
#define SYS_read_       63
#define SYS_write_      64
#define SYS_fstat_      80
#define SYS_exit_       93
#define SYS_nanosleep   101
#define SYS_sched_yield 124
#define SYS_times       153
#define SYS_uname       160
#define SYS_gettimeofday 169
#define SYS_getpid_     172
#define SYS_getppid     173
#define SYS_poweroff    210
#define SYS_brk         214
#define SYS_munmap      215
#define SYS_clone       220
#define SYS_execve      221
#define SYS_mmap        222
#define SYS_wait4       260
```

xv6-k210 将系统调用的汇编指令段进行了封装，提供了一个 C 函数的接口，在用户程序中，可以像使用普通函数一样调用。在 user.h 中声明了：

```
// xv6-user/user.h
int fork(void);
int exit(int) __attribute__((noreturn));
int wait(int*);
int pipe(int*);
int write(int, const void*, int);
...
```

并使用perl 语言脚本 usys.pl，重定向输出生成一个汇编源文件

```
#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/include/sysnum.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}

entry("fork");
entry("exit");
entry("wait");
entry("pipe");
entry("read");
entry("write");
```

syscall.h文件（在本节的前面）中宏定义了各个系统调用的调用号。RISC-V 的处理器在发生 trap 后会自动完成若干行为，但硬件并没有完成我们所需的所有操作，例如寄存器现场保护，还需进一步通过软件方式实现。跳转到 trap.c 中usertrap函数，再进入进入系统调用的处理函数 syscall.c 中的 syscall

```
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();
        // trace
    if ((p->tmask & (1 << num)) != 0) {
      printf("pid %d: %s -> %d\n", p->pid, sysnames[num], p->trapframe->a0);
    }
  } else {
    printf("pid %d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

上述代码中的 syscalls 数组为一个函数指针数组，指向各个系统调用的功能函数。

```
extern uint64 sys_fork(void);
extern uint64 sys_exit(void);
extern uint64 sys_wait(void);
......
static uint64 (*syscalls[])(void) = {
  [SYS_fork] sys_fork,
  [SYS_exit] sys_exit,
  [SYS_wait] sys_wait,
  ......
}
```

然后进入我们定义的系统调用函数中。系统功能调用完成后，将会从 syscall 函数返回至 usertrap 函数，并调用 trap.c中的 usertrapret。



## 文件系统

在本实验中我们使用FAT32文件系统。

file 的数据结构如下：

```c
struct file {
  enum { FD_NONE, FD_PIPE, FD_ENTRY, FD_DEVICE } type;
  int ref; // reference count
  char readable;
  char writable;
  struct pipe *pipe; // FD_PIPE
  struct dirent *ep;
  uint off;          // FD_ENTRY
  short major;       // FD_DEVICE
};
```

### SYS_getcwd

功能：获取当前工作目录；

输入：

- char *buf：一块缓存区，用于保存当前工作目录的字符串。当buf设为NULL，由系统来分配缓存区。
- size：buf缓存区的大小。

返回值：成功执行，则返回当前工作目录的字符串的指针。失败，则返回NULL。

实现方式：原有代码。将当前的工作目录绝对路径复制到参数 buf 所指的内存空间，参数 size 为 buf 的空间大小，执行成功则将结果复制
到参数 buf 所指的内存空间, 或是返回自动配置的字符串指针。

```c
uint64
sys_getcwd(void)
{
 uint64 addr;
  if (argaddr(0, &addr) < 0)
    return -1;

  struct dirent *de = myproc()->cwd;
  char path[FAT32_MAX_PATH];
  char *s;
  int len;

  if (de->parent == NULL) {
    s = "/";
  } else {
    s = path + FAT32_MAX_PATH - 1;
    *s = '\0';
    while (de->parent) {
      len = strlen(de->filename);
      s -= len;
      if (s <= path)          // can't reach root "/"
        return -1;
      strncpy(s, de->filename, len);
      *--s = '/';
      de = de->parent;
    }
  }
  if(addr==0){
    return 0;
  }
  // if (copyout(myproc()->pagetable, addr, s, strlen(s) + 1) < 0)
  if (copyout2(addr, s, strlen(s) + 1) < 0)
    return -1;
  return addr;
}
```



### SYS_pipe

功能：创建管道；

输入：

- fd[2]：用于保存2个文件描述符。其中，fd[0]为管道的读出端，fd[1]为管道的写入端。

返回值：成功执行，返回0。失败，返回-1。

实现方式： 原有代码。 fd0 和 fd1 分别构成管道的两端，并利用 copyout2 函数把 fd0 的信息拷到 fdarray 上

```c
uint64
sys_pipe(void)
{
  uint64 fdarray; // user pointer to array of two integers
  struct file *rf, *wf;
  int fd0, fd1;
  struct proc *p = myproc();

  if(argaddr(0, &fdarray) < 0)
    return -1;
  if(pipealloc(&rf, &wf) < 0)
    return -1;
  fd0 = -1;
  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
    if(fd0 >= 0)
      p->ofile[fd0] = 0;
    fileclose(rf);
    fileclose(wf);
    return -1;
  }
  // if(copyout(p->pagetable, fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||
  //    copyout(p->pagetable, fdarray+sizeof(fd0), (char *)&fd1, sizeof(fd1)) < 0){
  if(copyout2(fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||
     copyout2(fdarray+sizeof(fd0), (char *)&fd1, sizeof(fd1)) < 0){
    p->ofile[fd0] = 0;
    p->ofile[fd1] = 0;
    fileclose(rf);
    fileclose(wf);
    return -1;
  }
  return 0;
}

```



### SYS_dup

功能：复制文件描述符；

输入：

- fd：被复制的文件描述符。

返回值：成功执行，返回新的文件描述符。失败，返回-1。

实现方式：原有代码。获取系统调用的参数并存到指针 f 中，再将文件描述符对应的文件信息赋给 fd

```c
uint64
sys_dup(void)
{
  struct file *f;
  int fd;

  if(argfd(0, 0, &f) < 0)
    return -1;
  if((fd=fdalloc(f)) < 0)
    return -1;
  filedup(f);
  return fd;
}

```

### SYS_dup3

功能：复制文件描述符，并指定了新的文件描述符；

输入：

- old：被复制的文件描述符。
- new：新的文件描述符。

返回值：成功执行，返回新的文件描述符。失败，返回-1。

实现方式：获取被复制的文件描述符，存到指针f中，获取新的文件描述存到变量 number 中。
将文件传输到新的文件描述符中。

```c

uint64
sys_dup3(void)
{
  struct file *f;
  int newfd;
  
  if(argfd(0, 0, &f) < 0) 
    return -1;
  if(argint(1, &newfd) < 0 || newfd < 0)
    return -1;
  if(myproc()->ofile[newfd] != f) 
  {
    myproc()->ofile[newfd] = f;
    filedup(f);
  }
  //printf("Running: DUP3 ... newfd: %d \n", newfd);
  return newfd;
}
```


### SYS_chdir

功能：切换工作目录；

输入：

- path：需要切换到的目录。

返回值：成功执行，返回0。失败，返回-1。

实现方式：原有代码。如果路径名有效，内核定位该目录的索引节点，并检查它的文件类型和权限位，确保目标
文件是目录以及进程的所有者可以访问该目录 


```c
uint64
sys_chdir(void)
{
  char path[FAT32_MAX_PATH];
  struct dirent *ep;
  struct proc *curr_proc = myproc();
  
  if(argstr(0, path, FAT32_MAX_PATH) < 0 || (ep = ename(path)) == NULL){
    return -1;
  }
  //printf("Running: CHDIR ... path: %s\n",  path);
  elock(ep);
  if(!(ep->attribute & ATTR_DIRECTORY)){
    eunlock(ep);
    eput(ep);
    return -1;
  }
  eunlock(ep);
  eput(curr_proc->cwd);
  curr_proc->cwd = ep;
  return 0;
}
```

### SYS_openat

功能：打开或创建一个文件；

输入：

- fd：文件所在目录的文件描述符。
- filename：要打开或创建的文件名。如为绝对路径，则忽略fd。如为相对路径，且fd是AT_FDCWD，则filename是相对于当前工作目录来说的。如为相对路径，且fd是一个文件描述符，则filename是相对于fd所指向的目录来说的。
- flags：必须包含如下访问模式的其中一种：O_RDONLY，O_WRONLY，O_RDWR。还可以包含文件创建标志和文件状态标志。
- mode：文件的所有权描述。详见 `man 7 inode `。

返回值：成功执行，返回新的文件描述符。失败，返回-1。


实现方式：

我们定义
```
#define O_RDONLY  0x000
#define O_WRONLY  0x001
#define O_RDWR    0x002
#define O_APPEND  0x004
#define O_TRUNC   0x400
#define O_CREATE  0x40
#define O_DIRECTORY 0x0200000
```
来区分不同的文件打开标志

注意到，可能有绝对路径，那么fd相当于没有操作，而对于相对路径，要得到相对于fd为目录的文件目录，然后接下来的操作与系统给出的open并无二异。

```c
uint64
sys_openat(void)
{
  char path[FAT32_MAX_PATH];
  int flags, mode, fd;
  struct file *f, *dirf;
  struct dirent *dp = NULL, *ep;
  
  argfd(0, 0, &dirf);
  if(argstr(1, path, FAT32_MAX_PATH) < 0 || argint(2, &flags) < 0 || argint(3, &mode) < 0)
    return -1;
  
  if(mode == 0)
    mode = (flags & O_DIRECTORY) ? 0777 : 0666;
  if(mode | O_RDWR)
    flags |= O_RDWR;
  else if(mode == 0600)
    flags = flags; // clear execute
  
  if(dirf&&dirf->type==FD_ENTRY){
    dp = dirf->ep;
    elock(dp);
    if(!(dp->attribute & ATTR_DIRECTORY)){
      eunlock(dp);
      dp = NULL;
    }
  }
  if((ep = ename(path)) == NULL){
    if(flags & O_CREATE){
      ep = create(path, T_FILE, flags);
      if(ep == NULL)
        return -1;
    }
    if(!ep)
      return -1;
  }else
    elock(ep);
  if((ep->attribute & ATTR_DIRECTORY) && (!(flags&O_WRONLY) && !(flags&O_RDWR))){
    eunlock(ep);
    eput(ep);
    return -1;
  }
  if((f = filealloc()) == NULL || (fd = fdalloc(f)) < 0){
    if (f)
      fileclose(f);
    eunlock(ep);
    eput(ep);
    return -1;
  }
  if(!(ep->attribute & ATTR_DIRECTORY) && (flags & O_TRUNC))
    etrunc(ep);

  f->type = FD_ENTRY;
  f->off = (flags & O_APPEND) ? ep->file_size : 0;
  f->ep = ep;
  f->readable = !(flags & O_WRONLY);
  f->writable = (flags & O_WRONLY) || (flags & O_RDWR);
    
  eunlock(ep);
  if(dp)
    eunlock(dp);

  return fd;

}
```

### SYS_close

功能：关闭一个文件描述符；

输入：

- fd：要关闭的文件描述符。

返回值：成功执行，返回0。失败，返回-1。

实现方法：原有代码。

```c
uint64
sys_close(void)
{
  int fd;
  struct file *f;

  if(argfd(0, &fd, &f) < 0)
    return -1;
  myproc()->ofile[fd] = 0;
  fileclose(f);
  return 0;
}
```

### SYS_getdents64

功能：获取目录的条目;

输入：

- fd：所要读取目录的文件描述符。
- buf：一个缓存区，用于保存所读取目录的信息。
- len：buf的大小。

返回值：成功执行，返回读取的字节数。当到目录结尾，则返回0。失败，则返回-1。

实现方法：

我们先在fat32.h中构建所需要的dirent的结构，命名为__dirent__。

```c
struct __dirent__ {
    uint64 d_ino;	// 索引结点号
    int64 d_off;	// 到下一个dirent的偏移
    unsigned short d_reclen;	// 当前dirent的长度
    unsigned char d_type;	// 文件类型
    char d_name[];	//文件名
};
```

原有的dirent结构为

```c
struct dirent {
    char  filename[FAT32_MAX_FILENAME + 1];
    uint8   attribute;
    // uint8   create_time_tenth;
    // uint16  create_time;
    // uint16  create_date;
    // uint16  last_access_date;
    uint32  first_clus;
    // uint16  last_write_time;
    // uint16  last_write_date;
    uint32  file_size;

    uint32  cur_clus;
    uint    clus_cnt;

    /* for OS */
    uint8   dev;
    uint8   dirty;
    short   valid;
    int     ref;
    uint32  off;            // offset in the parent dir entry, for writing convenience
    struct dirent *parent;  // because FAT32 doesn't have such thing like inum, use this for cache trick
    struct dirent *next;
    struct dirent *prev;
    struct sleeplock    lock;
};
```

对原有的 dirnext 进行改造。使其能够接收新的dirent结构，并返回获取目录的条目

```c
//sysfile.c

uint64
sys_getdents64(void){
  struct file *f;
  uint64 buf;
  int len, fd;
  if (argfd(0, &fd, &f) < 0 || argaddr(1, &buf) < 0 || argint(2, &len) < 0)
    return -1;
  //printf("Running: getdent ... filefd: %d ... buf: 0x%x ... len: %d\n", fd, buf, len);
  return dirnext_(f,buf,len);
}

//file.c

int dirnext_(struct file *f, uint64 buffer, int len){
  struct __dirent__ *buf = (struct __dirent__ *)buffer, de;

  struct dirent *ep = f->ep, *d;
  if (ep == NULL)
    return -1;

  int i = 0, sum_s = 0;
  for (d = eroot(); d->next; d = d->next)
  {
    if (d->parent == ep)
    {
      de.d_ino = (long)d->parent + d->off;
      de.d_off = d - d->next;
      de.d_reclen = sizeof(de);
      de.d_type = f->type;
      safestrcpy(de.d_name, d->filename, sizeof(d->filename));

      if (sum_s + sizeof(de) > len)
        return sum_s;
      sum_s += sizeof(de);
      buf[i++] = de;
    }
  }
  return 0;
}
```

### SYS_read

功能：从一个文件描述符中读取；

输入：

- fd：要读取文件的文件描述符。
- buf：一个缓存区，用于存放读取的内容。
- count：要读取的字节数。

返回值：成功执行，返回读取的字节数。如为0，表示文件结束。错误，则返回-1。

实现方式：原有代码

```c
uint64
sys_read(void)
{
  struct file *f;
  int n;
  uint64 p;

  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0)
    return -1;
  return fileread(f, p, n);
}
```

### SYS_write

功能：从一个文件描述符中写入；

输入：

- fd：要写入文件的文件描述符。
- buf：一个缓存区，用于存放要写入的内容。
- count：要写入的字节数。

返回值：成功执行，返回写入的字节数。错误，则返回-1。
实现方式：原有代码

```c
uint64
sys_write(void)
{
  struct file *f;
  int n;
  uint64 p;

  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0)
    return -1;

  return filewrite(f, p, n);
}
```

### SYS_unlinkat

功能：移除指定文件的链接(可用于删除文件)；

输入：

- dirfd：要删除的链接所在的目录。
- path：要删除的链接的名字。如果path是相对路径，则它是相对于dirfd目录而言的。如果path是相对路径，且dirfd的值为AT_FDCWD，则它是相对于当前路径而言的。如果path是绝对路径，则dirfd被忽略。
- flags：可设置为0或AT_REMOVEDIR。

返回值：成功执行，返回0。失败，返回-1。

实现方式：获取系统调用的要删除的链接所在的目录，存到变量path中，用ename得到dirent struct。eremove(ep)可以删去文件的连接，成功返回0，失败返回-1。



```c
uint64 sys_unlinkat(struct dirent *mnt)
{
    char path[MAXPATH];
    int dirfd, flags;
    struct dirent *ep;  
    if (argint(0, &dirfd) < 0) 
      return -1;
    if (argstr(1, path, MAXPATH) < 0 || argint(2, &flags) < 0)
      return -1;
    if((ep = ename(path)) == NULL)
      return -1;    
    int isdir = ((ep->attribute & ATTR_DIRECTORY) ? T_DIR : T_FILE) == T_FILE ? 0 : 1;
    if (isdir && flags != AT_REMOVEDIR) {
      eput(ep);
      return -1;
    } else if (!isdir && flags == AT_REMOVEDIR) {
      eput(ep);
      return -1;
    }
    elock(ep);
    if (isdir && isdirempty(ep) != 1) {
      eunlock(ep);
      eput(ep);
      return -1;
    }
    eremove(ep); // dirty!  
    eunlock(ep);
    eput(ep);
    return 0;
}
```

### SYS_mkdirat

功能：创建目录；

输入：

- dirfd：要创建的目录所在的目录的文件描述符。
- path：要创建的目录的名称。如果path是相对路径，则它是相对于dirfd目录而言的。如果path是相对路径，且dirfd的值为AT_FDCWD，则它是相对于当前路径而言的。如果path是绝对路径，则dirfd被忽略。
- mode：文件的所有权描述。详见 `man 7 inode `。

返回值：成功执行，返回0。失败，返回-1。

实现方式：和原有的mkdirat类似。

```c
uint64
sys_mkdirat(void)
{

  char path[MAXPATH];
  int dirfd, mode;
  struct dirent *ep;

  if (argint(0, &dirfd) < 0 || argstr(1, path, MAXPATH) < 0 || argint(2, &mode) < 0) {
    return -1;
  }
  
  ep = create(path, T_DIR, mode);
  //printf("Running: MKDIRAT ... dirfd: %d ... mode: 0x%x... path: %s\n", dirfd, mode, path);

  eunlock(ep);
  eput(ep);
  return 0;
}
```

### SYS_umount2

功能：卸载文件系统；
输入：指定卸载目录，卸载参数；
返回值：成功返回0，失败返回-1；

实现方式：首先接收两个参数：要卸载的挂载点路径和卸载参数。函数首先检查输入参数是否有效，如果参数无效则返回-1。然后，函数尝试找到对应的挂载点目录项（dirent），如果找不到则返回-1。如果挂载点找到，函数会调用umount2函数来执行实际的卸载操作。在umount2中，会将挂载点的mount_flag设置为0，清空对应的设备信息，并重置设备索引。成功执行卸载操作后，返回0。


```c
//sysfile.h

uint64
sys_umount2(void)
{
  char mount_path[FAT32_MAX_PATH];
  int flags;
  struct dirent *mnt;

  if (argstr(0, mount_path, FAT32_MAX_PATH) < 0 || argint(1, &flags) < 0)
    return -1;

  if ((mnt = ename(mount_path)) == NULL)
    return -1;

  return umount2(mnt);
}

//fat32.h

int umount2(struct dirent *mnt)
{
    mnt->mount_flag = 0;
    memset(&devs[mnt->dev], 0, sizeof(devs[mnt->dev]));
    mnt->dev = 0;
    return 0;
}
```

### SYS_mount

功能：挂载文件系统；
输入：
- special: 挂载设备；
- dir: 挂载点；
- fstype: 挂载的文件系统类型；
- flags: 挂载参数；
- data: 传递给文件系统的字符串参数，可为NULL；
返回值：成功返回0，失败返回-1；

实现方法：接收五个参数：挂载设备、挂载点、文件系统类型、挂载参数和传递给文件系统的字符串参数。函数首先检查输入参数是否有效，如果参数无效则返回-1。然后，函数检查文件系统类型是否为支持的类型（如"vfat"或"fat32"），如果不是则返回-1。接下来，函数会调用mount函数来执行实际的挂载操作。在mount函数中，会首先找到一个新的索引来存储挂载信息，并读取挂载设备的BPB（BIOS参数块）信息，然后根据BPB信息计算出文件系统的一些关键参数，并初始化挂载点的目录项。最后，设置挂载点的mount_flag为1，并关联到对应的设备索引，成功挂载后返回0。

这两个函数的实现方法都涉及到参数检查、挂载点查找、设备信息处理和挂载点状态更新等关键步骤，以确保文件系统的安全和正确挂载或卸载。

```c
struct mntfs
{
    uint32 first_data_sec;
    uint32 data_sec_cnt;
    uint32 data_clus_cnt;
    uint32 byts_per_clus;

    struct
    {
        uint16 byts_per_sec;
        uint8 sec_per_clus;
        uint16 rsvd_sec_cnt;
        uint8 fat_cnt;   /* count of FAT regions */
        uint32 hidd_sec; /* count of hidden sectors */
        uint32 tot_sec;  /* total count of sectors including all regions */
        uint32 fat_sz;   /* count of sectors for a FAT region */
        uint32 root_clus;
    } bpb;

    int vaild;
    struct dirent root;
    uint8 mount_mode;
};
```




```c
uint64
sys_mount(void)
{
  char special[FAT32_MAX_PATH], dir[FAT32_MAX_PATH], fstype[FAT32_MAX_FILENAME];
  uint64 flags, data;

  if (argstr(0, special, FAT32_MAX_PATH) < 0 || argstr(1, dir, FAT32_MAX_PATH) < 0 || 
      argstr(2, fstype, FAT32_MAX_FILENAME) < 0 || argaddr(3, &flags) < 0 || argaddr(4, &data) < 0)
    return -1;
  struct dirent *dev = NULL, *mnt;
  if((mnt = ename(dir)) == NULL)
    return -1;

  if(strncmp("vfat", fstype, 5) != 0 && strncmp("fat32", fstype, 6) != 0)
    return -1;
  return mount(dev,mnt);
}

//file.c

static struct dirent root;

struct mntfs devs[8];
int idx = 0;

...

uint64 mount(struct dirent *dev, struct dirent *mnt){
    int idx = 0;
    while (devs[idx].vaild != 0){
          idx++;
          idx = idx % 8;
      }
    struct buf *b = bread(dev->dev, 0);
    if (strncmp((char const *)(b->data + 82), "FAT32", 5))
        panic("not FAT32 volume");
    memmove(&devs[idx].bpb.byts_per_sec, b->data + 11, 2); // avoid misaligned load on k210
    devs[idx].bpb.sec_per_clus = *(b->data + 13);
    devs[idx].bpb.rsvd_sec_cnt = *(uint16 *)(b->data + 14);
    devs[idx].bpb.fat_cnt = *(b->data + 16);
    devs[idx].bpb.hidd_sec = *(uint32 *)(b->data + 28);
    devs[idx].bpb.tot_sec = *(uint32 *)(b->data + 32);
    devs[idx].bpb.fat_sz = *(uint32 *)(b->data + 36);
    devs[idx].bpb.root_clus = *(uint32 *)(b->data + 44);
    devs[idx].first_data_sec = fat.bpb.rsvd_sec_cnt + fat.bpb.fat_cnt * fat.bpb.fat_sz;
    devs[idx].data_sec_cnt = fat.bpb.tot_sec - fat.first_data_sec;
    devs[idx].data_clus_cnt = fat.data_sec_cnt / fat.bpb.sec_per_clus;
    devs[idx].byts_per_clus = fat.bpb.sec_per_clus * fat.bpb.byts_per_sec;
    brelse(b);
    if (BSIZE != devs[idx].bpb.byts_per_sec)
        panic("byts_per_sec != BSIZE");
    initlock(&ecache.lock, "ecache");
    memset(&devs[idx].root, 0, sizeof(devs[idx].root));
    initsleeplock(&root.lock, "entry");
    devs[idx].root.attribute = (ATTR_DIRECTORY | ATTR_SYSTEM);
    devs[idx].root.first_clus = devs[idx].root.cur_clus = devs[idx].bpb.root_clus;
    devs[idx].root.valid = 1;
    devs[idx].root.prev = &devs[idx].root;
    devs[idx].root.next = &devs[idx].root;
    devs[idx].root.filename[0] = '/';
    devs[idx].root.filename[1] = '\0';
    devs[idx].mount_mode = 1;
    mnt->mount_flag = 1;
    mnt->dev = idx;
    return 0;
}
```

### SYS_fstat

* 功能：获取文件状态；
* 输入：
  - fd: 文件句柄；
  - kst: 接收保存文件状态的指针；
* 返回值：成功返回0，失败返回-1；
* 实现方式：接收两个参数：一个文件描述符和一个指向struct stat的用户空间指针，用于存储文件的状态信息。调用filestat函数来获取并返回文件的状态信息。

```
uint64
sys_fstat(void)
{
  struct file *f;
  uint64 st; // user pointer to struct stat

  if(argfd(0, 0, &f) < 0 || argaddr(1, &st) < 0)
    return -1;
  return filestat(f, st);
}
```

## 进程管理

### SYS_clone

* 功能：创建一个子进程；
* 输入：
  - flags: 创建的标志，如SIGCHLD；
  - stack: 指定新进程的栈，可为0；
  - ptid: 父线程ID；
  - tls: TLS线程本地存储描述符；
  - ctid: 子线程ID；
* 返回值：成功则返回子进程的线程ID，失败返回-1；
* 实现方式：接收两个参数：一个标志位flag和一个栈地址stack。函数首先检查这两个参数是否有效，如果无效则返回-1。如果提供了非零的栈地址，函数调用clone系统调用来创建一个具有指定栈的进程副本；如果没有提供栈地址，函数则调用fork来创建一个标准的子进程。

```c
uint64
sys_clone(void){
  uint64 flag, stack;
	if (argaddr(0, &flag) < 0) 
		return -1;
	if (argaddr(1, &stack) < 0) 
		return -1;
  ///printf("Running: CLONE ... flag: %ld ... stack: %ld\n", flag, stack);
  if (stack != 0)
	  return clone(flag, stack);
  else
    return fork();
}

```

### SYS_execve

* 功能：执行一个指定的程序；
* 输入：
  - path: 待执行程序路径名称，
  - argv: 程序的参数，
  - envp: 环境变量的数组指针
* 返回值：成功不返回，失败返回-1；
* 实现方法：从用户空间获取程序路径和参数列表的地址。然后，函数遍历参数列表，将每个参数从用户空间复制到内核空间，并存储在argv数组中。一旦所有参数都被复制，函数调用exec来加载并执行新的程序。如果执行过程中出现任何错误，或者参数列表解析完成，函数会释放分配的内存并返回错误代码。如果exec成功执行，函数返回执行结果；如果失败，返回-1。

```c

uint64
sys_execve(void)
{
  char path[FAT32_MAX_PATH], *argv[MAXARG];
  int i;
  uint64 uargv, uarg;

  if(argstr(0, path, FAT32_MAX_PATH) < 0 || argaddr(1, &uargv) < 0){
    return -1;
  }
  memset(argv, 0, sizeof(argv));
  for(i=0;; i++){
    if(i >= NELEM(argv)){
      goto bad;
    }
    if(fetchaddr(uargv+sizeof(uint64)*i, (uint64*)&uarg) < 0){
      goto bad;
    }
    if(uarg == 0){
      argv[i] = 0;
      break;
    }
    argv[i] = kalloc();
    if(argv[i] == 0)
      goto bad;
    if(fetchstr(uarg, argv[i], PGSIZE) < 0)
      goto bad;
  }

  int ret = exec(path, argv);

  for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
    kfree(argv[i]);

  return ret;

 bad:
  for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
    kfree(argv[i]);
  return -1;
}
```

### SYS_wait4

* 功能：等待进程改变状态;
* 输入：
  - pid: 指定进程ID，可为-1等待任何子进程；
  - status: 接收状态的指针；
  - options: 选项：WNOHANG，WUNTRACED，WCONTINUED；
* 返回值：成功则返回进程ID；如果指定了WNOHANG，且进程还未改变状态，直接返回0；失败则返回-1；
* 实现方式：接收三个参数：子进程的PID、用于存储子进程退出状态的指针和等待选项。函数首先检查这些参数是否有效，如果无效则返回-1。如果参数有效，函数调用waitpid来等待指定的子进程结束，并获取其退出状态。waitpid函数会阻塞当前进程直到子进程状态改变或满足指定的等待选项条件。如果成功，sys_wait4返回子进程的PID；如果失败，返回-1。

```c
uint64
sys_wait4(void)
{
  uint64 status;
  int pid, options;
  if(argaddr(1, &status) < 0 || argint(0, &pid) < 0 || argint(2, &options) < 0){
    return -1;}
  //printf("Running: WAIT4 ... pid: %ld ... options: %ld\n", pid, options);
  return waitpid(pid, status, options);
}

```

### SYS_exit 

* 功能：触发进程终止，无返回值；
* 输入：终止状态值；
* 返回值：无返回值；
* 实现方式：原有代码。
```c
uint64
sys_exit(void)
{
  int n;
  if(argint(0, &n) < 0)
    return -1;
  exit(n);
  return 0;  // not reached
}
```

### SYS_getppid

* 功能：获取父进程ID；
* 输入：系统调用ID；
* 返回值：成功返回父进程ID；

```c
uint64
sys_getppid(void)
{
  return myproc()->parent->pid;
}
```

### SYS_getpid

* 功能：获取进程ID；
* 输入：系统调用ID；
* 返回值：成功返回进程ID；

```c
uint64
sys_getpid(void)
{
  return myproc()->pid;
}
```

## 内存管理

### SYS_brk

* 功能：修改数据段的大小；
* 输入：指定待修改的地址；
* 返回值：成功返回0，失败返回-1;
* 实现方法：接收一个参数，即新的堆栈顶端地址new_addr。函数首先获取当前进程的数据段大小（old_addr）。如果new_addr为0，则直接返回当前的数据段大小。否则，计算新旧数据段大小的差值n，并调用growproc函数来调整进程的数据段大小。如果growproc成功，返回新的数据段大小；如果失败，返回-1



```c
uint64
sys_brk(void){
  uint64 new_addr, old_addr;
  int n;

  argaddr(0, &new_addr);
  old_addr = myproc()->sz;

  if(new_addr == 0)
    return old_addr;

  n = new_addr - old_addr;

  if(growproc(n) < 0)
    return -1;
  return new_addr;
}
```

### SYS_munmap && SYS_mmap

经过了很多尝试都是panic....
于是我放弃了....

## 其他

### SYS_times

* 功能：获取进程时间；
* 输入：tms结构体指针，用于获取保存当前进程的运行时间数据；
* 返回值：成功返回已经过去的滴答数，失败返回-1;
* 实现方式：首先接收一个参数，即用户空间的地址tms，用于存储时间信息。函数检查该地址是否有效，如果tms为0，则直接返回-1。如果tms有效，函数将当前进程的CPU时间信息（p->proc_tms）复制到用户空间的tms地址。复制成功后，函数返回系统启动以来的总运行时间r_time()；如果复制失败，则返回-1

```c
uint64
sys_times(void)
{
  uint64 tms;
  argaddr(0, &tms);
  struct proc *p = myproc();
  if (tms) {
    if(copyout2(tms, (char*)&p->proc_tms, sizeof(p->proc_tms)) == -1)
      return -1;
  }
  else
    return -1;
  return r_time();
}
```

### SYS_uname

* 功能：打印系统信息；
* 输入：utsname结构体指针用于获得系统信息数据；
* 返回值：成功返回0，失败返回-1;
* 实现方式：首先创建uts结构体

```c
struct utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
	char domainname[65];
};
```

系统调用中接收一个参数，即用户空间地址addr，用于存储系统信息结构utsname。函数检查该地址是否有效，如果无效则返回-1。

如果地址有效，函数将用户空间的utsname结构的各个字段分别指向系统定义的字符串，这些字符串包含了系统名称（SYSNAME）、节点名称（NODENAME）、版本号（RELEASE）、系统版本（VERSION）、机器类型（MACHINE）和域名（DOMAINNAME）。

函数使用copyout2函数将这些系统信息从内核空间复制到用户空间的对应字段中。如果复制过程中有任何失败，函数将返回-1。如果所有复制操作都成功，函数返回0，表示操作成功。
```c

uint64
sys_uname(void)
{
  uint64 addr;
  if(argaddr(0, &addr) < 0){
    return -1;
  }

  struct utsname* uts = (struct utsname*)addr;

  if (copyout2((uint64)uts->sysname, (void*)SYSNAME, sizeof(SYSNAME)) < 0) 
    return -1;
	if (copyout2((uint64)uts->nodename, (void*)NODENAME, sizeof(NODENAME)) < 0) 
    return -1;
	if (copyout2((uint64)uts->release, (void*)RELEASE, sizeof(RELEASE)) < 0)
    return -1;
	if (copyout2((uint64)uts->version, (void*)VERSION, sizeof(VERSION)) < 0) 
		return -1;
	if (copyout2((uint64)uts->machine, (void*)MACHINE, sizeof(MACHINE)) < 0) 
		return -1;
	if (copyout2((uint64)uts->domainname, (void*)DOMAINNAME, sizeof(DOMAINNAME)) < 0) 
		return -1;

  return 0;
}
```

### SYS_gettimeofday

* 功能：获取时间；
* 输入： timespec结构体指针用于获得时间值；
* 返回值：成功返回0，失败返回-1;
* 实现方法：定义一个TimeVal结构体变量tval，用于存储当前的时间值，包括秒数和微秒数。

```c
typedef struct
{
    uint64 sec;  // 自 Unix 纪元起的秒数
    uint64 usec; // 微秒数
} TimeVal;
```

获取系统启动以来的滴答数tmp_ticks，通过调用r_time函数获得。将滴答数转换为秒数，方法是将滴答数除以系统的时钟频率CLK_FREQ，然后乘以10（假设CLK_FREQ是每秒钟的滴答数）。检查用户是否提供了一个有效的地址ptval来存储timespec结构体，通过argaddr函数获取。
如果用户提供了有效的地址，使用copyout2函数将tval结构体的内容复制到用户空间的地址ptval处。如果copyout2函数调用成功，返回0表示操作成功；如果复制失败或argaddr函数调用失败，则返回-1表示操作失败


```c
uint64
sys_gettimeofday(void){
  TimeVal tval;
  uint64 tmp_ticks = r_time();
  tval.sec = tmp_ticks / CLK_FREQ * 10;
  uint64 ptval;
  if (argaddr(0, &ptval) < 0) {
		return -1;
	}
	if (ptval && copyout2(ptval, (char*)&tval, sizeof(tval)) < 0) {
		return -1;
	}
	return 0;
}
```